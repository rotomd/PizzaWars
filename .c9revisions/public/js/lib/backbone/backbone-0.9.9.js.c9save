{"ts":1356658894293,"silentsave":true,"restoring":false,"patch":[[]],"length":0}
{"contributors":[],"silentsave":false,"ts":1356658890671,"patch":[[{"diffs":[[1,"//     Backbone.js 0.9.9\r\n\r\n//     (c) 2010-2012 Jeremy Ashkenas, DocumentCloud Inc.\r\n//     Backbone may be freely distributed under the MIT license.\r\n//     For all details and documentation:\r\n//     http://backbonejs.org\r\n\r\n(function(){\r\n\r\n  // Initial Setup\r\n  // -------------\r\n\r\n  // Save a reference to the global object (`window` in the browser, `exports`\r\n  // on the server).\r\n  var root = this;\r\n\r\n  // Save the previous value of the `Backbone` variable, so that it can be\r\n  // restored later on, if `noConflict` is used.\r\n  var previousBackbone = root.Backbone;\r\n\r\n  // Create a local reference to array methods.\r\n  var array = [];\r\n  var push = array.push;\r\n  var slice = array.slice;\r\n  var splice = array.splice;\r\n\r\n  // The top-level namespace. All public Backbone classes and modules will\r\n  // be attached to this. Exported for both CommonJS and the browser.\r\n  var Backbone;\r\n  if (typeof exports !== 'undefined') {\r\n    Backbone = exports;\r\n  } else {\r\n    Backbone = root.Backbone = {};\r\n  }\r\n\r\n  // Current version of the library. Keep in sync with `package.json`.\r\n  Backbone.VERSION = '0.9.9';\r\n\r\n  // Require Underscore, if we're on the server, and it's not already present.\r\n  var _ = root._;\r\n  if (!_ && (typeof require !== 'undefined')) _ = require('underscore');\r\n\r\n  // For Backbone's purposes, jQuery, Zepto, or Ender owns the `$` variable.\r\n  Backbone.$ = root.jQuery || root.Zepto || root.ender;\r\n\r\n  // Runs Backbone.js in *noConflict* mode, returning the `Backbone` variable\r\n  // to its previous owner. Returns a reference to this Backbone object.\r\n  Backbone.noConflict = function() {\r\n    root.Backbone = previousBackbone;\r\n    return this;\r\n  };\r\n\r\n  // Turn on `emulateHTTP` to support legacy HTTP servers. Setting this option\r\n  // will fake `\"PUT\"` and `\"DELETE\"` requests via the `_method` parameter and\r\n  // set a `X-Http-Method-Override` header.\r\n  Backbone.emulateHTTP = false;\r\n\r\n  // Turn on `emulateJSON` to support legacy servers that can't deal with direct\r\n  // `application/json` requests ... will encode the body as\r\n  // `application/x-www-form-urlencoded` instead and will send the model in a\r\n  // form param named `model`.\r\n  Backbone.emulateJSON = false;\r\n\r\n  // Backbone.Events\r\n  // ---------------\r\n\r\n  // Regular expression used to split event strings.\r\n  var eventSplitter = /\\s+/;\r\n\r\n  // Implement fancy features of the Events API such as multiple event\r\n  // names `\"change blur\"` and jQuery-style event maps `{change: action}`\r\n  // in terms of the existing API.\r\n  var eventsApi = function(obj, action, name, rest) {\r\n    if (!name) return true;\r\n    if (typeof name === 'object') {\r\n      for (var key in name) {\r\n        obj[action].apply(obj, [key, name[key]].concat(rest));\r\n      }\r\n    } else if (eventSplitter.test(name)) {\r\n      var names = name.split(eventSplitter);\r\n      for (var i = 0, l = names.length; i < l; i++) {\r\n        obj[action].apply(obj, [names[i]].concat(rest));\r\n      }\r\n    } else {\r\n      return true;\r\n    }\r\n  };\r\n\r\n  // Optimized internal dispatch function for triggering events. Tries to\r\n  // keep the usual cases speedy (most Backbone events have 3 arguments).\r\n  var triggerEvents = function(obj, events, args) {\r\n    var ev, i = -1, l = events.length;\r\n    switch (args.length) {\r\n    case 0: while (++i < l) (ev = events[i]).callback.call(ev.ctx);\r\n    return;\r\n    case 1: while (++i < l) (ev = events[i]).callback.call(ev.ctx, args[0]);\r\n    return;\r\n    case 2: while (++i < l) (ev = events[i]).callback.call(ev.ctx, args[0], args[1]);\r\n    return;\r\n    case 3: while (++i < l) (ev = events[i]).callback.call(ev.ctx, args[0], args[1], args[2]);\r\n    return;\r\n    default: while (++i < l) (ev = events[i]).callback.apply(ev.ctx, args);\r\n    }\r\n  };\r\n\r\n  // A module that can be mixed in to *any object* in order to provide it with\r\n  // custom events. You may bind with `on` or remove with `off` callback\r\n  // functions to an event; `trigger`-ing an event fires all callbacks in\r\n  // succession.\r\n  //\r\n  //     var object = {};\r\n  //     _.extend(object, Backbone.Events);\r\n  //     object.on('expand', function(){ alert('expanded'); });\r\n  //     object.trigger('expand');\r\n  //\r\n  var Events = Backbone.Events = {\r\n\r\n    // Bind one or more space separated events, or an events map,\r\n    // to a `callback` function. Passing `\"all\"` will bind the callback to\r\n    // all events fired.\r\n    on: function(name, callback, context) {\r\n      if (!(eventsApi(this, 'on', name, [callback, context]) && callback)) return this;\r\n      this._events || (this._events = {});\r\n      var list = this._events[name] || (this._events[name] = []);\r\n      list.push({callback: callback, context: context, ctx: context || this});\r\n      return this;\r\n    },\r\n\r\n    // Bind events to only be triggered a single time. After the first time\r\n    // the callback is invoked, it will be removed.\r\n    once: function(name, callback, context) {\r\n      if (!(eventsApi(this, 'once', name, [callback, context]) && callback)) return this;\r\n      var self = this;\r\n      var once = _.once(function() {\r\n        self.off(name, once);\r\n        callback.apply(this, arguments);\r\n      });\r\n      once._callback = callback;\r\n      this.on(name, once, context);\r\n      return this;\r\n    },\r\n\r\n    // Remove one or many callbacks. If `context` is null, removes all\r\n    // callbacks with that function. If `callback` is null, removes all\r\n    // callbacks for the event. If `events` is null, removes all bound\r\n    // callbacks for all events.\r\n    off: function(name, callback, context) {\r\n      var list, ev, events, names, i, l, j, k;\r\n      if (!this._events || !eventsApi(this, 'off', name, [callback, context])) return this;\r\n      if (!name && !callback && !context) {\r\n        this._events = {};\r\n        return this;\r\n      }\r\n\r\n      names = name ? [name] : _.keys(this._events);\r\n      for (i = 0, l = names.length; i < l; i++) {\r\n        name = names[i];\r\n        if (list = this._events[name]) {\r\n          events = [];\r\n          if (callback || context) {\r\n            for (j = 0, k = list.length; j < k; j++) {\r\n              ev = list[j];\r\n              if ((callback && callback !== (ev.callback._callback || ev.callback)) ||\r\n                  (context && context !== ev.context)) {\r\n                events.push(ev);\r\n              }\r\n            }\r\n          }\r\n          this._events[name] = events;\r\n        }\r\n      }\r\n\r\n      return this;\r\n    },\r\n\r\n    // Trigger one or many events, firing all bound callbacks. Callbacks are\r\n    // passed the same arguments as `trigger` is, apart from the event name\r\n    // (unless you're listening on `\"all\"`, which will cause your callback to\r\n    // receive the true name of the event as the first argument).\r\n    trigger: function(name) {\r\n      if (!this._events) return this;\r\n      var args = slice.call(arguments, 1);\r\n      if (!eventsApi(this, 'trigger', name, args)) return this;\r\n      var events = this._events[name];\r\n      var allEvents = this._events.all;\r\n      if (events) triggerEvents(this, events, args);\r\n      if (allEvents) triggerEvents(this, allEvents, arguments);\r\n      return this;\r\n    },\r\n\r\n    // An inversion-of-control version of `on`. Tell *this* object to listen to\r\n    // an event in another object ... keeping track of what it's listening to.\r\n    listenTo: function(object, events, callback) {\r\n      var listeners = this._listeners || (this._listeners = {});\r\n      var id = object._listenerId || (object._listenerId = _.uniqueId('l'));\r\n      listeners[id] = object;\r\n      object.on(events, callback || this, this);\r\n      return this;\r\n    },\r\n\r\n    // Tell this object to stop listening to either specific events ... or\r\n    // to every object it's currently listening to.\r\n    stopListening: function(object, events, callback) {\r\n      var listeners = this._listeners;\r\n      if (!listeners) return;\r\n      if (object) {\r\n        object.off(events, callback, this);\r\n        if (!events && !callback) delete listeners[object._listenerId];\r\n      } else {\r\n        for (var id in listeners) {\r\n          listeners[id].off(null, null, this);\r\n        }\r\n        this._listeners = {};\r\n      }\r\n      return this;\r\n    }\r\n  };\r\n\r\n  // Aliases for backwards compatibility.\r\n  Events.bind   = Events.on;\r\n  Events.unbind = Events.off;\r\n\r\n  // Allow the `Backbone` object to serve as a global event bus, for folks who\r\n  // want global \"pubsub\" in a convenient place.\r\n  _.extend(Backbone, Events);\r\n\r\n  // Backbone.Model\r\n  // --------------\r\n\r\n  // Create a new model, with defined attributes. A client id (`cid`)\r\n  // is automatically generated and assigned for you.\r\n  var Model = Backbone.Model = function(attributes, options) {\r\n    var defaults;\r\n    var attrs = attributes || {};\r\n    this.cid = _.uniqueId('c');\r\n    this.changed = {};\r\n    this.attributes = {};\r\n    this._changes = [];\r\n    if (options && options.collection) this.collection = options.collection;\r\n    if (options && options.parse) attrs = this.parse(attrs);\r\n    if (defaults = _.result(this, 'defaults')) _.defaults(attrs, defaults);\r\n    this.set(attrs, {silent: true});\r\n    this._currentAttributes = _.clone(this.attributes);\r\n    this._previousAttributes = _.clone(this.attributes);\r\n    this.initialize.apply(this, arguments);\r\n  };\r\n\r\n  // Attach all inheritable methods to the Model prototype.\r\n  _.extend(Model.prototype, Events, {\r\n\r\n    // A hash of attributes whose current and previous value differ.\r\n    changed: null,\r\n\r\n    // The default name for the JSON `id` attribute is `\"id\"`. MongoDB and\r\n    // CouchDB users may want to set this to `\"_id\"`.\r\n    idAttribute: 'id',\r\n\r\n    // Initialize is an empty function by default. Override it with your own\r\n    // initialization logic.\r\n    initialize: function(){},\r\n\r\n    // Return a copy of the model's `attributes` object.\r\n    toJSON: function(options) {\r\n      return _.clone(this.attributes);\r\n    },\r\n\r\n    // Proxy `Backbone.sync` by default.\r\n    sync: function() {\r\n      return Backbone.sync.apply(this, arguments);\r\n    },\r\n\r\n    // Get the value of an attribute.\r\n    get: function(attr) {\r\n      return this.attributes[attr];\r\n    },\r\n\r\n    // Get the HTML-escaped value of an attribute.\r\n    escape: function(attr) {\r\n      return _.escape(this.get(attr));\r\n    },\r\n\r\n    // Returns `true` if the attribute contains a value that is not null\r\n    // or undefined.\r\n    has: function(attr) {\r\n      return this.get(attr) != null;\r\n    },\r\n\r\n    // Set a hash of model attributes on the object, firing `\"change\"` unless\r\n    // you choose to silence it.\r\n    set: function(key, val, options) {\r\n      var attr, attrs;\r\n      if (key == null) return this;\r\n\r\n      // Handle both `\"key\", value` and `{key: value}` -style arguments.\r\n      if (_.isObject(key)) {\r\n        attrs = key;\r\n        options = val;\r\n      } else {\r\n        (attrs = {})[key] = val;\r\n      }\r\n\r\n      // Extract attributes and options.\r\n      var silent = options && options.silent;\r\n      var unset = options && options.unset;\r\n\r\n      // Run validation.\r\n      if (!this._validate(attrs, options)) return false;\r\n\r\n      // Check for changes of `id`.\r\n      if (this.idAttribute in attrs) this.id = attrs[this.idAttribute];\r\n\r\n      var now = this.attributes;\r\n\r\n      // For each `set` attribute...\r\n      for (attr in attrs) {\r\n        val = attrs[attr];\r\n\r\n        // Update or delete the current value, and track the change.\r\n        unset ? delete now[attr] : now[attr] = val;\r\n        this._changes.push(attr, val);\r\n      }\r\n\r\n      // Signal that the model's state has potentially changed, and we need\r\n      // to recompute the actual changes.\r\n      this._hasComputed = false;\r\n\r\n      // Fire the `\"change\"` events.\r\n      if (!silent) this.change(options);\r\n      return this;\r\n    },\r\n\r\n    // Remove an attribute from the model, firing `\"change\"` unless you choose\r\n    // to silence it. `unset` is a noop if the attribute doesn't exist.\r\n    unset: function(attr, options) {\r\n      return this.set(attr, void 0, _.extend({}, options, {unset: true}));\r\n    },\r\n\r\n    // Clear all attributes on the model, firing `\"change\"` unless you choose\r\n    // to silence it.\r\n    clear: function(options) {\r\n      var attrs = {};\r\n      for (var key in this.attributes) attrs[key] = void 0;\r\n      return this.set(attrs, _.extend({}, options, {unset: true}));\r\n    },\r\n\r\n    // Fetch the model from the server. If the server's representation of the\r\n    // model differs from its current attributes, they will be overriden,\r\n    // triggering a `\"change\"` event.\r\n    fetch: function(options) {\r\n      options = options ? _.clone(options) : {};\r\n      if (options.parse === void 0) options.parse = true;\r\n      var model = this;\r\n      var success = options.success;\r\n      options.success = function(resp, status, xhr) {\r\n        if (!model.set(model.parse(resp), options)) return false;\r\n        if (success) success(model, resp, options);\r\n      };\r\n      return this.sync('read', this, options);\r\n    },\r\n\r\n    // Set a hash of model attributes, and sync the model to the server.\r\n    // If the server returns an attributes hash that differs, the model's\r\n    // state will be `set` again.\r\n    save: function(key, val, options) {\r\n      var attrs, current, done;\r\n\r\n      // Handle both `\"key\", value` and `{key: value}` -style arguments.\r\n      if (key == null || _.isObject(key)) {\r\n        attrs = key;\r\n        options = val;\r\n      } else if (key != null) {\r\n        (attrs = {})[key] = val;\r\n      }\r\n      options = options ? _.clone(options) : {};\r\n\r\n      // If we're \"wait\"-ing to set changed attributes, validate early.\r\n      if (options.wait) {\r\n        if (attrs && !this._validate(attrs, options)) return false;\r\n        current = _.clone(this.attributes);\r\n      }\r\n\r\n      // Regular saves `set` attributes before persisting to the server.\r\n      var silentOptions = _.extend({}, options, {silent: true});\r\n      if (attrs && !this.set(attrs, options.wait ? silentOptions : options)) {\r\n        return false;\r\n      }\r\n\r\n      // Do not persist invalid models.\r\n      if (!attrs && !this._validate(null, options)) return false;\r\n\r\n      // After a successful server-side save, the client is (optionally)\r\n      // updated with the server-side state.\r\n      var model = this;\r\n      var success = options.success;\r\n      options.success = function(resp, status, xhr) {\r\n        done = true;\r\n        var serverAttrs = model.parse(resp);\r\n        if (options.wait) serverAttrs = _.extend(attrs || {}, serverAttrs);\r\n        if (!model.set(serverAttrs, options)) return false;\r\n        if (success) success(model, resp, options);\r\n      };\r\n\r\n      // Finish configuring and sending the Ajax request.\r\n      var method = this.isNew() ? 'create' : (options.patch ? 'patch' : 'update');\r\n      if (method == 'patch') options.attrs = attrs;\r\n      var xhr = this.sync(method, this, options);\r\n\r\n      // When using `wait`, reset attributes to original values unless\r\n      // `success` has been called already.\r\n      if (!done && options.wait) {\r\n        this.clear(silentOptions);\r\n        this.set(current, silentOptions);\r\n      }\r\n\r\n      return xhr;\r\n    },\r\n\r\n    // Destroy this model on the server if it was already persisted.\r\n    // Optimistically removes the model from its collection, if it has one.\r\n    // If `wait: true` is passed, waits for the server to respond before removal.\r\n    destroy: function(options) {\r\n      options = options ? _.clone(options) : {};\r\n      var model = this;\r\n      var success = options.success;\r\n\r\n      var destroy = function() {\r\n        model.trigger('destroy', model, model.collection, options);\r\n      };\r\n\r\n      options.success = function(resp) {\r\n        if (options.wait || model.isNew()) destroy();\r\n        if (success) success(model, resp, options);\r\n      };\r\n\r\n      if (this.isNew()) {\r\n        options.success();\r\n        return false;\r\n      }\r\n\r\n      var xhr = this.sync('delete', this, options);\r\n      if (!options.wait) destroy();\r\n      return xhr;\r\n    },\r\n\r\n    // Default URL for the model's representation on the server -- if you're\r\n    // using Backbone's restful methods, override this to change the endpoint\r\n    // that will be called.\r\n    url: function() {\r\n      var base = _.result(this, 'urlRoot') || _.result(this.collection, 'url') || urlError();\r\n      if (this.isNew()) return base;\r\n      return base + (base.charAt(base.length - 1) === '/' ? '' : '/') + encodeURIComponent(this.id);\r\n    },\r\n\r\n    // **parse** converts a response into the hash of attributes to be `set` on\r\n    // the model. The default implementation is just to pass the response along.\r\n    parse: function(resp) {\r\n      return resp;\r\n    },\r\n\r\n    // Create a new model with identical attributes to this one.\r\n    clone: function() {\r\n      return new this.constructor(this.attributes);\r\n    },\r\n\r\n    // A model is new if it has never been saved to the server, and lacks an id.\r\n    isNew: function() {\r\n      return this.id == null;\r\n    },\r\n\r\n    // Call this method to manually fire a `\"change\"` event for this model and\r\n    // a `\"change:attribute\"` event for each changed attribute.\r\n    // Calling this will cause all objects observing the model to update.\r\n    change: function(options) {\r\n      var changing = this._changing;\r\n      this._changing = true;\r\n\r\n      // Generate the changes to be triggered on the model.\r\n      var triggers = this._computeChanges(true);\r\n\r\n      this._pending = !!triggers.length;\r\n\r\n      for (var i = triggers.length - 2; i >= 0; i -= 2) {\r\n        this.trigger('change:' + triggers[i], this, triggers[i + 1], options);\r\n      }\r\n\r\n      if (changing) return this;\r\n\r\n      // Trigger a `change` while there have been changes.\r\n      while (this._pending) {\r\n        this._pending = false;\r\n        this.trigger('change', this, options);\r\n        this._previousAttributes = _.clone(this.attributes);\r\n      }\r\n\r\n      this._changing = false;\r\n      return this;\r\n    },\r\n\r\n    // Determine if the model has changed since the last `\"change\"` event.\r\n    // If you specify an attribute name, determine if that attribute has changed.\r\n    hasChanged: function(attr) {\r\n      if (!this._hasComputed) this._computeChanges();\r\n      if (attr == null) return !_.isEmpty(this.changed);\r\n      return _.has(this.changed, attr);\r\n    },\r\n\r\n    // Return an object containing all the attributes that have changed, or\r\n    // false if there are no changed attributes. Useful for determining what\r\n    // parts of a view need to be updated and/or what attributes need to be\r\n    // persisted to the server. Unset attributes will be set to undefined.\r\n    // You can also pass an attributes object to diff against the model,\r\n    // determining if there *would be* a change.\r\n    changedAttributes: function(diff) {\r\n      if (!diff) return this.hasChanged() ? _.clone(this.changed) : false;\r\n      var val, changed = false, old = this._previousAttributes;\r\n      for (var attr in diff) {\r\n        if (_.isEqual(old[attr], (val = diff[attr]))) continue;\r\n        (changed || (changed = {}))[attr] = val;\r\n      }\r\n      return changed;\r\n    },\r\n\r\n    // Looking at the built up list of `set` attribute changes, compute how\r\n    // many of the attributes have actually changed. If `loud`, return a\r\n    // boiled-down list of only the real changes.\r\n    _computeChanges: function(loud) {\r\n      this.changed = {};\r\n      var already = {};\r\n      var triggers = [];\r\n      var current = this._currentAttributes;\r\n      var changes = this._changes;\r\n\r\n      // Loop through the current queue of potential model changes.\r\n      for (var i = changes.length - 2; i >= 0; i -= 2) {\r\n        var key = changes[i], val = changes[i + 1];\r\n        if (already[key]) continue;\r\n        already[key] = true;\r\n\r\n        // Check if the attribute has been modified since the last change,\r\n        // and update `this.changed` accordingly. If we're inside of a `change`\r\n        // call, also add a trigger to the list.\r\n        if (current[key] !== val) {\r\n          this.changed[key] = val;\r\n          if (!loud) continue;\r\n          triggers.push(key, val);\r\n          current[key] = val;\r\n        }\r\n      }\r\n      if (loud) this._changes = [];\r\n\r\n      // Signals `this.changed` is current to prevent duplicate calls from `this.hasChanged`.\r\n      this._hasComputed = true;\r\n      return triggers;\r\n    },\r\n\r\n    // Get the previous value of an attribute, recorded at the time the last\r\n    // `\"change\"` event was fired.\r\n    previous: function(attr) {\r\n      if (attr == null || !this._previousAttributes) return null;\r\n      return this._previousAttributes[attr];\r\n    },\r\n\r\n    // Get all of the attributes of the model at the time of the previous\r\n    // `\"change\"` event.\r\n    previousAttributes: function() {\r\n      return _.clone(this._previousAttributes);\r\n    },\r\n\r\n    // Run validation against the next complete set of model attributes,\r\n    // returning `true` if all is well. If a specific `error` callback has\r\n    // been passed, call that instead of firing the general `\"error\"` event.\r\n    _validate: function(attrs, options) {\r\n      if (!this.validate) return true;\r\n      attrs = _.extend({}, this.attributes, attrs);\r\n      var error = this.validate(attrs, options);\r\n      if (!error) return true;\r\n      if (options && options.error) options.error(this, error, options);\r\n      this.trigger('error', this, error, options);\r\n      return false;\r\n    }\r\n\r\n  });\r\n\r\n  // Backbone.Collection\r\n  // -------------------\r\n\r\n  // Provides a standard collection class for our sets of models, ordered\r\n  // or unordered. If a `comparator` is specified, the Collection will maintain\r\n  // its models in sort order, as they're added and removed.\r\n  var Collection = Backbone.Collection = function(models, options) {\r\n    options || (options = {});\r\n    if (options.model) this.model = options.model;\r\n    if (options.comparator !== void 0) this.comparator = options.comparator;\r\n    this._reset();\r\n    this.initialize.apply(this, arguments);\r\n    if (models) this.reset(models, _.extend({silent: true}, options));\r\n  };\r\n\r\n  // Define the Collection's inheritable methods.\r\n  _.extend(Collection.prototype, Events, {\r\n\r\n    // The default model for a collection is just a **Backbone.Model**.\r\n    // This should be overridden in most cases.\r\n    model: Model,\r\n\r\n    // Initialize is an empty function by default. Override it with your own\r\n    // initialization logic.\r\n    initialize: function(){},\r\n\r\n    // The JSON representation of a Collection is an array of the\r\n    // models' attributes.\r\n    toJSON: function(options) {\r\n      return this.map(function(model){ return model.toJSON(options); });\r\n    },\r\n\r\n    // Proxy `Backbone.sync` by default.\r\n    sync: function() {\r\n      return Backbone.sync.apply(this, arguments);\r\n    },\r\n\r\n    // Add a model, or list of models to the set. Pass **silent** to avoid\r\n    // firing the `add` event for every new model.\r\n    add: function(models, options) {\r\n      var i, args, length, model, existing, needsSort;\r\n      var at = options && options.at;\r\n      var sort = ((options && options.sort) == null ? true : options.sort);\r\n      models = _.isArray(models) ? models.slice() : [models];\r\n\r\n      // Turn bare objects into model references, and prevent invalid models\r\n      // from being added.\r\n      for (i = models.length - 1; i >= 0; i--) {\r\n        if(!(model = this._prepareModel(models[i], options))) {\r\n          this.trigger(\"error\", this, models[i], options);\r\n          models.splice(i, 1);\r\n          continue;\r\n        }\r\n        models[i] = model;\r\n\r\n        existing = model.id != null && this._byId[model.id];\r\n        // If a duplicate is found, prevent it from being added and\r\n        // optionally merge it into the existing model.\r\n        if (existing || this._byCid[model.cid]) {\r\n          if (options && options.merge && existing) {\r\n            existing.set(model.attributes, options);\r\n            needsSort = sort;\r\n          }\r\n          models.splice(i, 1);\r\n          continue;\r\n        }\r\n\r\n        // Listen to added models' events, and index models for lookup by\r\n        // `id` and by `cid`.\r\n        model.on('all', this._onModelEvent, this);\r\n        this._byCid[model.cid] = model;\r\n        if (model.id != null) this._byId[model.id] = model;\r\n      }\r\n\r\n      // See if sorting is needed, update `length` and splice in new models.\r\n      if (models.length) needsSort = sort;\r\n      this.length += models.length;\r\n      args = [at != null ? at : this.models.length, 0];\r\n      push.apply(args, models);\r\n      splice.apply(this.models, args);\r\n\r\n      // Sort the collection if appropriate.\r\n      if (needsSort && this.comparator && at == null) this.sort({silent: true});\r\n\r\n      if (options && options.silent) return this;\r\n\r\n      // Trigger `add` events.\r\n      while (model = models.shift()) {\r\n        model.trigger('add', model, this, options);\r\n      }\r\n\r\n      return this;\r\n    },\r\n\r\n    // Remove a model, or a list of models from the set. Pass silent to avoid\r\n    // firing the `remove` event for every model removed.\r\n    remove: function(models, options) {\r\n      var i, l, index, model;\r\n      options || (options = {});\r\n      models = _.isArray(models) ? models.slice() : [models];\r\n      for (i = 0, l = models.length; i < l; i++) {\r\n        model = this.get(models[i]);\r\n        if (!model) continue;\r\n        delete this._byId[model.id];\r\n        delete this._byCid[model.cid];\r\n        index = this.indexOf(model);\r\n        this.models.splice(index, 1);\r\n        this.length--;\r\n        if (!options.silent) {\r\n          options.index = index;\r\n          model.trigger('remove', model, this, options);\r\n        }\r\n        this._removeReference(model);\r\n      }\r\n      return this;\r\n    },\r\n\r\n    // Add a model to the end of the collection.\r\n    push: function(model, options) {\r\n      model = this._prepareModel(model, options);\r\n      this.add(model, _.extend({at: this.length}, options));\r\n      return model;\r\n    },\r\n\r\n    // Remove a model from the end of the collection.\r\n    pop: function(options) {\r\n      var model = this.at(this.length - 1);\r\n      this.remove(model, options);\r\n      return model;\r\n    },\r\n\r\n    // Add a model to the beginning of the collection.\r\n    unshift: function(model, options) {\r\n      model = this._prepareModel(model, options);\r\n      this.add(model, _.extend({at: 0}, options));\r\n      return model;\r\n    },\r\n\r\n    // Remove a model from the beginning of the collection.\r\n    shift: function(options) {\r\n      var model = this.at(0);\r\n      this.remove(model, options);\r\n      return model;\r\n    },\r\n\r\n    // Slice out a sub-array of models from the collection.\r\n    slice: function(begin, end) {\r\n      return this.models.slice(begin, end);\r\n    },\r\n\r\n    // Get a model from the set by id.\r\n    get: function(obj) {\r\n      if (obj == null) return void 0;\r\n      return this._byId[obj.id != null ? obj.id : obj] || this._byCid[obj.cid || obj];\r\n    },\r\n\r\n    // Get the model at the given index.\r\n    at: function(index) {\r\n      return this.models[index];\r\n    },\r\n\r\n    // Return models with matching attributes. Useful for simple cases of `filter`.\r\n    where: function(attrs) {\r\n      if (_.isEmpty(attrs)) return [];\r\n      return this.filter(function(model) {\r\n        for (var key in attrs) {\r\n          if (attrs[key] !== model.get(key)) return false;\r\n        }\r\n        return true;\r\n      });\r\n    },\r\n\r\n    // Force the collection to re-sort itself. You don't need to call this under\r\n    // normal circumstances, as the set will maintain sort order as each item\r\n    // is added.\r\n    sort: function(options) {\r\n      if (!this.comparator) {\r\n        throw new Error('Cannot sort a set without a comparator');\r\n      }\r\n\r\n      if (_.isString(this.comparator) || this.comparator.length === 1) {\r\n        this.models = this.sortBy(this.comparator, this);\r\n      } else {\r\n        this.models.sort(_.bind(this.comparator, this));\r\n      }\r\n\r\n      if (!options || !options.silent) this.trigger('sort', this, options);\r\n      return this;\r\n    },\r\n\r\n    // Pluck an attribute from each model in the collection.\r\n    pluck: function(attr) {\r\n      return _.invoke(this.models, 'get', attr);\r\n    },\r\n\r\n    // Smartly update a collection with a change set of models, adding,\r\n    // removing, and merging as necessary.\r\n    update: function(models, options) {\r\n      var model, i, l, existing;\r\n      var add = [], remove = [], modelMap = {};\r\n      var idAttr = this.model.prototype.idAttribute;\r\n      options = _.extend({add: true, merge: true, remove: true}, options);\r\n      if (options.parse) models = this.parse(models);\r\n\r\n      // Allow a single model (or no argument) to be passed.\r\n      if (!_.isArray(models)) models = models ? [models] : [];\r\n\r\n      // Proxy to `add` for this case, no need to iterate...\r\n      if (options.add && !options.remove) return this.add(models, options);\r\n\r\n      // Determine which models to add and merge, and which to remove.\r\n      for (i = 0, l = models.length; i < l; i++) {\r\n        model = models[i];\r\n        existing = this.get(model.id || model.cid || model[idAttr]);\r\n        if (options.remove && existing) modelMap[existing.cid] = true;\r\n        if ((options.add && !existing) || (options.merge && existing)) {\r\n          add.push(model);\r\n        }\r\n      }\r\n      if (options.remove) {\r\n        for (i = 0, l = this.models.length; i < l; i++) {\r\n          model = this.models[i];\r\n          if (!modelMap[model.cid]) remove.push(model);\r\n        }\r\n      }\r\n\r\n      // Remove models (if applicable) before we add and merge the rest.\r\n      if (remove.length) this.remove(remove, options);\r\n      if (add.length) this.add(add, options);\r\n      return this;\r\n    },\r\n\r\n    // When you have more items than you want to add or remove individually,\r\n    // you can reset the entire set with a new list of models, without firing\r\n    // any `add` or `remove` events. Fires `reset` when finished.\r\n    reset: function(models, options) {\r\n      options || (options = {});\r\n      if (options.parse) models = this.parse(models);\r\n      for (var i = 0, l = this.models.length; i < l; i++) {\r\n        this._removeReference(this.models[i]);\r\n      }\r\n      options.previousModels = this.models;\r\n      this._reset();\r\n      if (models) this.add(models, _.extend({silent: true}, options));\r\n      if (!options.silent) this.trigger('reset', this, options);\r\n      return this;\r\n    },\r\n\r\n    // Fetch the default set of models for this collection, resetting the\r\n    // collection when they arrive. If `add: true` is passed, appends the\r\n    // models to the collection instead of resetting.\r\n    fetch: function(options) {\r\n      options = options ? _.clone(options) : {};\r\n      if (options.parse === void 0) options.parse = true;\r\n      var collection = this;\r\n      var success = options.success;\r\n      options.success = function(resp, status, xhr) {\r\n        var method = options.update ? 'update' : 'reset';\r\n        collection[method](resp, options);\r\n        if (success) success(collection, resp, options);\r\n      };\r\n      return this.sync('read', this, options);\r\n    },\r\n\r\n    // Create a new instance of a model in this collection. Add the model to the\r\n    // collection immediately, unless `wait: true` is passed, in which case we\r\n    // wait for the server to agree.\r\n    create: function(model, options) {\r\n      var collection = this;\r\n      options = options ? _.clone(options) : {};\r\n      model = this._prepareModel(model, options);\r\n      if (!model) return false;\r\n      if (!options.wait) collection.add(model, options);\r\n      var success = options.success;\r\n      options.success = function(model, resp, options) {\r\n        if (options.wait) collection.add(model, options);\r\n        if (success) success(model, resp, options);\r\n      };\r\n      model.save(null, options);\r\n      return model;\r\n    },\r\n\r\n    // **parse** converts a response into a list of models to be added to the\r\n    // collection. The default implementation is just to pass it through.\r\n    parse: function(resp) {\r\n      return resp;\r\n    },\r\n\r\n    // Create a new collection with an identical list of models as this one.\r\n    clone: function() {\r\n      return new this.constructor(this.models);\r\n    },\r\n\r\n    // Proxy to _'s chain. Can't be proxied the same way the rest of the\r\n    // underscore methods are proxied because it relies on the underscore\r\n    // constructor.\r\n    chain: function() {\r\n      return _(this.models).chain();\r\n    },\r\n\r\n    // Reset all internal state. Called when the collection is reset.\r\n    _reset: function() {\r\n      this.length = 0;\r\n      this.models = [];\r\n      this._byId  = {};\r\n      this._byCid = {};\r\n    },\r\n\r\n    // Prepare a model or hash of attributes to be added to this collection.\r\n    _prepareModel: function(attrs, options) {\r\n      if (attrs instanceof Model) {\r\n        if (!attrs.collection) attrs.collection = this;\r\n        return attrs;\r\n      }\r\n      options || (options = {});\r\n      options.collection = this;\r\n      var model = new this.model(attrs, options);\r\n      if (!model._validate(attrs, options)) return false;\r\n      return model;\r\n    },\r\n\r\n    // Internal method to remove a model's ties to a collection.\r\n    _removeReference: function(model) {\r\n      if (this === model.collection) delete model.collection;\r\n      model.off('all', this._onModelEvent, this);\r\n    },\r\n\r\n    // Internal method called every time a model in the set fires an event.\r\n    // Sets need to update their indexes when models change ids. All other\r\n    // events simply proxy through. \"add\" and \"remove\" events that originate\r\n    // in other collections are ignored.\r\n    _onModelEvent: function(event, model, collection, options) {\r\n      if ((event === 'add' || event === 'remove') && collection !== this) return;\r\n      if (event === 'destroy') this.remove(model, options);\r\n      if (model && event === 'change:' + model.idAttribute) {\r\n        delete this._byId[model.previous(model.idAttribute)];\r\n        if (model.id != null) this._byId[model.id] = model;\r\n      }\r\n      this.trigger.apply(this, arguments);\r\n    }\r\n\r\n  });\r\n\r\n  // Underscore methods that we want to implement on the Collection.\r\n  var methods = ['forEach', 'each', 'map', 'collect', 'reduce', 'foldl',\r\n    'inject', 'reduceRight', 'foldr', 'find', 'detect', 'filter', 'select',\r\n    'reject', 'every', 'all', 'some', 'any', 'include', 'contains', 'invoke',\r\n    'max', 'min', 'sortedIndex', 'toArray', 'size', 'first', 'head', 'take',\r\n    'initial', 'rest', 'tail', 'last', 'without', 'indexOf', 'shuffle',\r\n    'lastIndexOf', 'isEmpty'];\r\n\r\n  // Mix in each Underscore method as a proxy to `Collection#models`.\r\n  _.each(methods, function(method) {\r\n    Collection.prototype[method] = function() {\r\n      var args = slice.call(arguments);\r\n      args.unshift(this.models);\r\n      return _[method].apply(_, args);\r\n    };\r\n  });\r\n\r\n  // Underscore methods that take a property name as an argument.\r\n  var attributeMethods = ['groupBy', 'countBy', 'sortBy'];\r\n\r\n  // Use attributes instead of properties.\r\n  _.each(attributeMethods, function(method) {\r\n    Collection.prototype[method] = function(value, context) {\r\n      var iterator = _.isFunction(value) ? value : function(model) {\r\n        return model.get(value);\r\n      };\r\n      return _[method](this.models, iterator, context);\r\n    };\r\n  });\r\n\r\n  // Backbone.Router\r\n  // ---------------\r\n\r\n  // Routers map faux-URLs to actions, and fire events when routes are\r\n  // matched. Creating a new one sets its `routes` hash, if not set statically.\r\n  var Router = Backbone.Router = function(options) {\r\n    options || (options = {});\r\n    if (options.routes) this.routes = options.routes;\r\n    this._bindRoutes();\r\n    this.initialize.apply(this, arguments);\r\n  };\r\n\r\n  // Cached regular expressions for matching named param parts and splatted\r\n  // parts of route strings.\r\n  var optionalParam = /\\((.*?)\\)/g;\r\n  var namedParam    = /:\\w+/g;\r\n  var splatParam    = /\\*\\w+/g;\r\n  var escapeRegExp  = /[\\-{}\\[\\]+?.,\\\\\\^$|#\\s]/g;\r\n\r\n  // Set up all inheritable **Backbone.Router** properties and methods.\r\n  _.extend(Router.prototype, Events, {\r\n\r\n    // Initialize is an empty function by default. Override it with your own\r\n    // initialization logic.\r\n    initialize: function(){},\r\n\r\n    // Manually bind a single named route to a callback. For example:\r\n    //\r\n    //     this.route('search/:query/p:num', 'search', function(query, num) {\r\n    //       ...\r\n    //     });\r\n    //\r\n    route: function(route, name, callback) {\r\n      if (!_.isRegExp(route)) route = this._routeToRegExp(route);\r\n      if (!callback) callback = this[name];\r\n      Backbone.history.route(route, _.bind(function(fragment) {\r\n        var args = this._extractParameters(route, fragment);\r\n        callback && callback.apply(this, args);\r\n        this.trigger.apply(this, ['route:' + name].concat(args));\r\n        Backbone.history.trigger('route', this, name, args);\r\n      }, this));\r\n      return this;\r\n    },\r\n\r\n    // Simple proxy to `Backbone.history` to save a fragment into the history.\r\n    navigate: function(fragment, options) {\r\n      Backbone.history.navigate(fragment, options);\r\n      return this;\r\n    },\r\n\r\n    // Bind all defined routes to `Backbone.history`. We have to reverse the\r\n    // order of the routes here to support behavior where the most general\r\n    // routes can be defined at the bottom of the route map.\r\n    _bindRoutes: function() {\r\n      if (!this.routes) return;\r\n      var route, routes = _.keys(this.routes);\r\n      while ((route = routes.pop()) != null) {\r\n        this.route(route, this.routes[route]);\r\n      }\r\n    },\r\n\r\n    // Convert a route string into a regular expression, suitable for matching\r\n    // against the current location hash.\r\n    _routeToRegExp: function(route) {\r\n      route = route.replace(escapeRegExp, '\\\\$&')\r\n                   .replace(optionalParam, '(?:$1)?')\r\n                   .replace(namedParam, '([^\\/]+)')\r\n                   .replace(splatParam, '(.*?)');\r\n      return new RegExp('^' + route + '$');\r\n    },\r\n\r\n    // Given a route, and a URL fragment that it matches, return the array of\r\n    // extracted parameters.\r\n    _extractParameters: function(route, fragment) {\r\n      return route.exec(fragment).slice(1);\r\n    }\r\n\r\n  });\r\n\r\n  // Backbone.History\r\n  // ----------------\r\n\r\n  // Handles cross-browser history management, based on URL fragments. If the\r\n  // browser does not support `onhashchange`, falls back to polling.\r\n  var History = Backbone.History = function() {\r\n    this.handlers = [];\r\n    _.bindAll(this, 'checkUrl');\r\n\r\n    // Ensure that `History` can be used outside of the browser.\r\n    if (typeof window !== 'undefined') {\r\n      this.location = window.location;\r\n      this.history = window.history;\r\n    }\r\n  };\r\n\r\n  // Cached regex for stripping a leading hash/slash and trailing space.\r\n  var routeStripper = /^[#\\/]|\\s+$/g;\r\n\r\n  // Cached regex for stripping leading and trailing slashes.\r\n  var rootStripper = /^\\/+|\\/+$/g;\r\n\r\n  // Cached regex for detecting MSIE.\r\n  var isExplorer = /msie [\\w.]+/;\r\n\r\n  // Cached regex for removing a trailing slash.\r\n  var trailingSlash = /\\/$/;\r\n\r\n  // Has the history handling already been started?\r\n  History.started = false;\r\n\r\n  // Set up all inheritable **Backbone.History** properties and methods.\r\n  _.extend(History.prototype, Events, {\r\n\r\n    // The default interval to poll for hash changes, if necessary, is\r\n    // twenty times a second.\r\n    interval: 50,\r\n\r\n    // Gets the true hash value. Cannot use location.hash directly due to bug\r\n    // in Firefox where location.hash will always be decoded.\r\n    getHash: function(window) {\r\n      var match = (window || this).location.href.match(/#(.*)$/);\r\n      return match ? match[1] : '';\r\n    },\r\n\r\n    // Get the cross-browser normalized URL fragment, either from the URL,\r\n    // the hash, or the override.\r\n    getFragment: function(fragment, forcePushState) {\r\n      if (fragment == null) {\r\n        if (this._hasPushState || !this._wantsHashChange || forcePushState) {\r\n          fragment = this.location.pathname;\r\n          var root = this.root.replace(trailingSlash, '');\r\n          if (!fragment.indexOf(root)) fragment = fragment.substr(root.length);\r\n        } else {\r\n          fragment = this.getHash();\r\n        }\r\n      }\r\n      return fragment.replace(routeStripper, '');\r\n    },\r\n\r\n    // Start the hash change handling, returning `true` if the current URL matches\r\n    // an existing route, and `false` otherwise.\r\n    start: function(options) {\r\n      if (History.started) throw new Error(\"Backbone.history has already been started\");\r\n      History.started = true;\r\n\r\n      // Figure out the initial configuration. Do we need an iframe?\r\n      // Is pushState desired ... is it available?\r\n      this.options          = _.extend({}, {root: '/'}, this.options, options);\r\n      this.root             = this.options.root;\r\n      this._wantsHashChange = this.options.hashChange !== false;\r\n      this._wantsPushState  = !!this.options.pushState;\r\n      this._hasPushState    = !!(this.options.pushState && this.history && this.history.pushState);\r\n      var fragment          = this.getFragment();\r\n      var docMode           = document.documentMode;\r\n      var oldIE             = (isExplorer.exec(navigator.userAgent.toLowerCase()) && (!docMode || docMode <= 7));\r\n\r\n      // Normalize root to always include a leading and trailing slash.\r\n      this.root = ('/' + this.root + '/').replace(rootStripper, '/');\r\n\r\n      if (oldIE && this._wantsHashChange) {\r\n        this.iframe = Backbone.$('<iframe src=\"javascript:0\" tabindex=\"-1\" />').hide().appendTo('body')[0].contentWindow;\r\n        this.navigate(fragment);\r\n      }\r\n\r\n      // Depending on whether we're using pushState or hashes, and whether\r\n      // 'onhashchange' is supported, determine how we check the URL state.\r\n      if (this._hasPushState) {\r\n        Backbone.$(window).bind('popstate', this.checkUrl);\r\n      } else if (this._wantsHashChange && ('onhashchange' in window) && !oldIE) {\r\n        Backbone.$(window).bind('hashchange', this.checkUrl);\r\n      } else if (this._wantsHashChange) {\r\n        this._checkUrlInterval = setInterval(this.checkUrl, this.interval);\r\n      }\r\n\r\n      // Determine if we need to change the base url, for a pushState link\r\n      // opened by a non-pushState browser.\r\n      this.fragment = fragment;\r\n      var loc = this.location;\r\n      var atRoot = loc.pathname.replace(/[^\\/]$/, '$&/') === this.root;\r\n\r\n      // If we've started off with a route from a `pushState`-enabled browser,\r\n      // but we're currently in a browser that doesn't support it...\r\n      if (this._wantsHashChange && this._wantsPushState && !this._hasPushState && !atRoot) {\r\n        this.fragment = this.getFragment(null, true);\r\n        this.location.replace(this.root + this.location.search + '#' + this.fragment);\r\n        // Return immediately as browser will do redirect to new url\r\n        return true;\r\n\r\n      // Or if we've started out with a hash-based route, but we're currently\r\n      // in a browser where it could be `pushState`-based instead...\r\n      } else if (this._wantsPushState && this._hasPushState && atRoot && loc.hash) {\r\n        this.fragment = this.getHash().replace(routeStripper, '');\r\n        this.history.replaceState({}, document.title, this.root + this.fragment + loc.search);\r\n      }\r\n\r\n      if (!this.options.silent) return this.loadUrl();\r\n    },\r\n\r\n    // Disable Backbone.history, perhaps temporarily. Not useful in a real app,\r\n    // but possibly useful for unit testing Routers.\r\n    stop: function() {\r\n      Backbone.$(window).unbind('popstate', this.checkUrl).unbind('hashchange', this.checkUrl);\r\n      clearInterval(this._checkUrlInterval);\r\n      History.started = false;\r\n    },\r\n\r\n    // Add a route to be tested when the fragment changes. Routes added later\r\n    // may override previous routes.\r\n    route: function(route, callback) {\r\n      this.handlers.unshift({route: route, callback: callback});\r\n    },\r\n\r\n    // Checks the current URL to see if it has changed, and if it has,\r\n    // calls `loadUrl`, normalizing across the hidden iframe.\r\n    checkUrl: function(e) {\r\n      var current = this.getFragment();\r\n      if (current === this.fragment && this.iframe) {\r\n        current = this.getFragment(this.getHash(this.iframe));\r\n      }\r\n      if (current === this.fragment) return false;\r\n      if (this.iframe) this.navigate(current);\r\n      this.loadUrl() || this.loadUrl(this.getHash());\r\n    },\r\n\r\n    // Attempt to load the current URL fragment. If a route succeeds with a\r\n    // match, returns `true`. If no defined routes matches the fragment,\r\n    // returns `false`.\r\n    loadUrl: function(fragmentOverride) {\r\n      var fragment = this.fragment = this.getFragment(fragmentOverride);\r\n      var matched = _.any(this.handlers, function(handler) {\r\n        if (handler.route.test(fragment)) {\r\n          handler.callback(fragment);\r\n          return true;\r\n        }\r\n      });\r\n      return matched;\r\n    },\r\n\r\n    // Save a fragment into the hash history, or replace the URL state if the\r\n    // 'replace' option is passed. You are responsible for properly URL-encoding\r\n    // the fragment in advance.\r\n    //\r\n    // The options object can contain `trigger: true` if you wish to have the\r\n    // route callback be fired (not usually desirable), or `replace: true`, if\r\n    // you wish to modify the current URL without adding an entry to the history.\r\n    navigate: function(fragment, options) {\r\n      if (!History.started) return false;\r\n      if (!options || options === true) options = {trigger: options};\r\n      fragment = this.getFragment(fragment || '');\r\n      if (this.fragment === fragment) return;\r\n      this.fragment = fragment;\r\n      var url = this.root + fragment;\r\n\r\n      // If pushState is available, we use it to set the fragment as a real URL.\r\n      if (this._hasPushState) {\r\n        this.history[options.replace ? 'replaceState' : 'pushState']({}, document.title, url);\r\n\r\n      // If hash changes haven't been explicitly disabled, update the hash\r\n      // fragment to store history.\r\n      } else if (this._wantsHashChange) {\r\n        this._updateHash(this.location, fragment, options.replace);\r\n        if (this.iframe && (fragment !== this.getFragment(this.getHash(this.iframe)))) {\r\n          // Opening and closing the iframe tricks IE7 and earlier to push a\r\n          // history entry on hash-tag change.  When replace is true, we don't\r\n          // want this.\r\n          if(!options.replace) this.iframe.document.open().close();\r\n          this._updateHash(this.iframe.location, fragment, options.replace);\r\n        }\r\n\r\n      // If you've told us that you explicitly don't want fallback hashchange-\r\n      // based history, then `navigate` becomes a page refresh.\r\n      } else {\r\n        return this.location.assign(url);\r\n      }\r\n      if (options.trigger) this.loadUrl(fragment);\r\n    },\r\n\r\n    // Update the hash location, either replacing the current entry, or adding\r\n    // a new one to the browser history.\r\n    _updateHash: function(location, fragment, replace) {\r\n      if (replace) {\r\n        var href = location.href.replace(/(javascript:|#).*$/, '');\r\n        location.replace(href + '#' + fragment);\r\n      } else {\r\n        // Some browsers require that `hash` contains a leading #.\r\n        location.hash = '#' + fragment;\r\n      }\r\n    }\r\n\r\n  });\r\n\r\n  // Create the default Backbone.history.\r\n  Backbone.history = new History;\r\n\r\n  // Backbone.View\r\n  // -------------\r\n\r\n  // Creating a Backbone.View creates its initial element outside of the DOM,\r\n  // if an existing element is not provided...\r\n  var View = Backbone.View = function(options) {\r\n    this.cid = _.uniqueId('view');\r\n    this._configure(options || {});\r\n    this._ensureElement();\r\n    this.initialize.apply(this, arguments);\r\n    this.delegateEvents();\r\n  };\r\n\r\n  // Cached regex to split keys for `delegate`.\r\n  var delegateEventSplitter = /^(\\S+)\\s*(.*)$/;\r\n\r\n  // List of view options to be merged as properties.\r\n  var viewOptions = ['model', 'collection', 'el', 'id', 'attributes', 'className', 'tagName', 'events'];\r\n\r\n  // Set up all inheritable **Backbone.View** properties and methods.\r\n  _.extend(View.prototype, Events, {\r\n\r\n    // The default `tagName` of a View's element is `\"div\"`.\r\n    tagName: 'div',\r\n\r\n    // jQuery delegate for element lookup, scoped to DOM elements within the\r\n    // current view. This should be prefered to global lookups where possible.\r\n    $: function(selector) {\r\n      return this.$el.find(selector);\r\n    },\r\n\r\n    // Initialize is an empty function by default. Override it with your own\r\n    // initialization logic.\r\n    initialize: function(){},\r\n\r\n    // **render** is the core function that your view should override, in order\r\n    // to populate its element (`this.el`), with the appropriate HTML. The\r\n    // convention is for **render** to always return `this`.\r\n    render: function() {\r\n      return this;\r\n    },\r\n\r\n    // Remove this view by taking the element out of the DOM, and removing any\r\n    // applicable Backbone.Events listeners.\r\n    remove: function() {\r\n      this.$el.remove();\r\n      this.stopListening();\r\n      return this;\r\n    },\r\n\r\n    // For small amounts of DOM Elements, where a full-blown template isn't\r\n    // needed, use **make** to manufacture elements, one at a time.\r\n    //\r\n    //     var el = this.make('li', {'class': 'row'}, this.model.escape('title'));\r\n    //\r\n    make: function(tagName, attributes, content) {\r\n      var el = document.createElement(tagName);\r\n      if (attributes) Backbone.$(el).attr(attributes);\r\n      if (content != null) Backbone.$(el).html(content);\r\n      return el;\r\n    },\r\n\r\n    // Change the view's element (`this.el` property), including event\r\n    // re-delegation.\r\n    setElement: function(element, delegate) {\r\n      if (this.$el) this.undelegateEvents();\r\n      this.$el = element instanceof Backbone.$ ? element : Backbone.$(element);\r\n      this.el = this.$el[0];\r\n      if (delegate !== false) this.delegateEvents();\r\n      return this;\r\n    },\r\n\r\n    // Set callbacks, where `this.events` is a hash of\r\n    //\r\n    // *{\"event selector\": \"callback\"}*\r\n    //\r\n    //     {\r\n    //       'mousedown .title':  'edit',\r\n    //       'click .button':     'save'\r\n    //       'click .open':       function(e) { ... }\r\n    //     }\r\n    //\r\n    // pairs. Callbacks will be bound to the view, with `this` set properly.\r\n    // Uses event delegation for efficiency.\r\n    // Omitting the selector binds the event to `this.el`.\r\n    // This only works for delegate-able events: not `focus`, `blur`, and\r\n    // not `change`, `submit`, and `reset` in Internet Explorer.\r\n    delegateEvents: function(events) {\r\n      if (!(events || (events = _.result(this, 'events')))) return;\r\n      this.undelegateEvents();\r\n      for (var key in events) {\r\n        var method = events[key];\r\n        if (!_.isFunction(method)) method = this[events[key]];\r\n        if (!method) throw new Error('Method \"' + events[key] + '\" does not exist');\r\n        var match = key.match(delegateEventSplitter);\r\n        var eventName = match[1], selector = match[2];\r\n        method = _.bind(method, this);\r\n        eventName += '.delegateEvents' + this.cid;\r\n        if (selector === '') {\r\n          this.$el.bind(eventName, method);\r\n        } else {\r\n          this.$el.delegate(selector, eventName, method);\r\n        }\r\n      }\r\n    },\r\n\r\n    // Clears all callbacks previously bound to the view with `delegateEvents`.\r\n    // You usually don't need to use this, but may wish to if you have multiple\r\n    // Backbone views attached to the same DOM element.\r\n    undelegateEvents: function() {\r\n      this.$el.unbind('.delegateEvents' + this.cid);\r\n    },\r\n\r\n    // Performs the initial configuration of a View with a set of options.\r\n    // Keys with special meaning *(model, collection, id, className)*, are\r\n    // attached directly to the view.\r\n    _configure: function(options) {\r\n      if (this.options) options = _.extend({}, _.result(this, 'options'), options);\r\n      _.extend(this, _.pick(options, viewOptions));\r\n      this.options = options;\r\n    },\r\n\r\n    // Ensure that the View has a DOM element to render into.\r\n    // If `this.el` is a string, pass it through `$()`, take the first\r\n    // matching element, and re-assign it to `el`. Otherwise, create\r\n    // an element from the `id`, `className` and `tagName` properties.\r\n    _ensureElement: function() {\r\n      if (!this.el) {\r\n        var attrs = _.extend({}, _.result(this, 'attributes'));\r\n        if (this.id) attrs.id = _.result(this, 'id');\r\n        if (this.className) attrs['class'] = _.result(this, 'className');\r\n        this.setElement(this.make(_.result(this, 'tagName'), attrs), false);\r\n      } else {\r\n        this.setElement(_.result(this, 'el'), false);\r\n      }\r\n    }\r\n\r\n  });\r\n\r\n  // Backbone.sync\r\n  // -------------\r\n\r\n  // Map from CRUD to HTTP for our default `Backbone.sync` implementation.\r\n  var methodMap = {\r\n    'create': 'POST',\r\n    'update': 'PUT',\r\n    'patch':  'PATCH',\r\n    'delete': 'DELETE',\r\n    'read':   'GET'\r\n  };\r\n\r\n  // Override this function to change the manner in which Backbone persists\r\n  // models to the server. You will be passed the type of request, and the\r\n  // model in question. By default, makes a RESTful Ajax request\r\n  // to the model's `url()`. Some possible customizations could be:\r\n  //\r\n  // * Use `setTimeout` to batch rapid-fire updates into a single request.\r\n  // * Send up the models as XML instead of JSON.\r\n  // * Persist models via WebSockets instead of Ajax.\r\n  //\r\n  // Turn on `Backbone.emulateHTTP` in order to send `PUT` and `DELETE` requests\r\n  // as `POST`, with a `_method` parameter containing the true HTTP method,\r\n  // as well as all requests with the body as `application/x-www-form-urlencoded`\r\n  // instead of `application/json` with the model in a param named `model`.\r\n  // Useful when interfacing with server-side languages like **PHP** that make\r\n  // it difficult to read the body of `PUT` requests.\r\n  Backbone.sync = function(method, model, options) {\r\n    var type = methodMap[method];\r\n\r\n    // Default options, unless specified.\r\n    _.defaults(options || (options = {}), {\r\n      emulateHTTP: Backbone.emulateHTTP,\r\n      emulateJSON: Backbone.emulateJSON\r\n    });\r\n\r\n    // Default JSON-request options.\r\n    var params = {type: type, dataType: 'json'};\r\n\r\n    // Ensure that we have a URL.\r\n    if (!options.url) {\r\n      params.url = _.result(model, 'url') || urlError();\r\n    }\r\n\r\n    // Ensure that we have the appropriate request data.\r\n    if (options.data == null && model && (method === 'create' || method === 'update' || method === 'patch')) {\r\n      params.contentType = 'application/json';\r\n      params.data = JSON.stringify(options.attrs || model.toJSON(options));\r\n    }\r\n\r\n    // For older servers, emulate JSON by encoding the request into an HTML-form.\r\n    if (options.emulateJSON) {\r\n      params.contentType = 'application/x-www-form-urlencoded';\r\n      params.data = params.data ? {model: params.data} : {};\r\n    }\r\n\r\n    // For older servers, emulate HTTP by mimicking the HTTP method with `_method`\r\n    // And an `X-HTTP-Method-Override` header.\r\n    if (options.emulateHTTP && (type === 'PUT' || type === 'DELETE' || type === 'PATCH')) {\r\n      params.type = 'POST';\r\n      if (options.emulateJSON) params.data._method = type;\r\n      var beforeSend = options.beforeSend;\r\n      options.beforeSend = function(xhr) {\r\n        xhr.setRequestHeader('X-HTTP-Method-Override', type);\r\n        if (beforeSend) return beforeSend.apply(this, arguments);\r\n      };\r\n    }\r\n\r\n    // Don't process data on a non-GET request.\r\n    if (params.type !== 'GET' && !options.emulateJSON) {\r\n      params.processData = false;\r\n    }\r\n\r\n    var success = options.success;\r\n    options.success = function(resp, status, xhr) {\r\n      if (success) success(resp, status, xhr);\r\n      model.trigger('sync', model, resp, options);\r\n    };\r\n\r\n    var error = options.error;\r\n    options.error = function(xhr, status, thrown) {\r\n      if (error) error(model, xhr, options);\r\n      model.trigger('error', model, xhr, options);\r\n    };\r\n\r\n    // Make the request, allowing the user to override any Ajax options.\r\n    var xhr = Backbone.ajax(_.extend(params, options));\r\n    model.trigger('request', model, xhr, options);\r\n    return xhr;\r\n  };\r\n\r\n  // Set the default implementation of `Backbone.ajax` to proxy through to `$`.\r\n  Backbone.ajax = function() {\r\n    return Backbone.$.ajax.apply(Backbone.$, arguments);\r\n  };\r\n\r\n  // Helpers\r\n  // -------\r\n\r\n  // Helper function to correctly set up the prototype chain, for subclasses.\r\n  // Similar to `goog.inherits`, but uses a hash of prototype properties and\r\n  // class properties to be extended.\r\n  var extend = function(protoProps, staticProps) {\r\n    var parent = this;\r\n    var child;\r\n\r\n    // The constructor function for the new subclass is either defined by you\r\n    // (the \"constructor\" property in your `extend` definition), or defaulted\r\n    // by us to simply call the parent's constructor.\r\n    if (protoProps && _.has(protoProps, 'constructor')) {\r\n      child = protoProps.constructor;\r\n    } else {\r\n      child = function(){ parent.apply(this, arguments); };\r\n    }\r\n\r\n    // Add static properties to the constructor function, if supplied.\r\n    _.extend(child, parent, staticProps);\r\n\r\n    // Set the prototype chain to inherit from `parent`, without calling\r\n    // `parent`'s constructor function.\r\n    var Surrogate = function(){ this.constructor = child; };\r\n    Surrogate.prototype = parent.prototype;\r\n    child.prototype = new Surrogate;\r\n\r\n    // Add prototype properties (instance properties) to the subclass,\r\n    // if supplied.\r\n    if (protoProps) _.extend(child.prototype, protoProps);\r\n\r\n    // Set a convenience property in case the parent's prototype is needed\r\n    // later.\r\n    child.__super__ = parent.prototype;\r\n\r\n    return child;\r\n  };\r\n\r\n  // Set up inheritance for the model, collection, router, view and history.\r\n  Model.extend = Collection.extend = Router.extend = View.extend = History.extend = extend;\r\n\r\n  // Throw an error when a URL is needed, and none is supplied.\r\n  var urlError = function() {\r\n    throw new Error('A \"url\" property or function must be specified');\r\n  };\r\n\r\n}).call(this);"]],"start1":0,"start2":0,"length1":0,"length2":58586}]],"length":58586,"saved":false}
